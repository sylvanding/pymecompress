# PYMECompress 算法原理

## 概述

PYMECompress专为光子噪声限制的图像设计，核心思想是：**量化误差保持在泊松噪声范围内，从而实现"视觉无损"的压缩**。

## 泊松噪声模型

### 光子计数统计

在荧光显微镜等成像系统中，每个像素的信号服从泊松分布：

```
P(k; λ) = (λ^k * e^(-λ)) / k!
```

其中：
- `k`: 实际观测到的光子数
- `λ`: 期望光子数（真实信号）

### 噪声特性

泊松分布的标准差：

```
σ = √λ
```

即：**噪声幅度等于信号的平方根**

这是光子计数图像的固有噪声，无法消除。

### "噪声内压缩"策略

既然噪声不可避免，我们可以将量化误差控制在噪声范围内：

```
|量化值 - 真实值| ≤ σ = √真实值
```

这样，压缩引入的误差**淹没在固有噪声中**，视觉上无法区分。

## 量化算法

### 问题建模

将16位信号量化为8位，同时保持误差在噪声范围内。

### 数学推导

设原始信号为 `I`（uint16），量化后为 `Q`（uint8），要求：

```
|I - Î| ≤ √I
```

其中 `Î` 是从 `Q` 反量化得到的值。

#### 方法：平方根量化

采用平方根变换：

```
Q = √((I - offset) / scale)
```

反量化：

```
Î = Q² * scale + offset
```

#### 误差分析

量化误差：

```
ε = |I - Î| = |I - (Q² * scale + offset)|
```

由于 `Q = floor(√((I - offset) / scale))`，最大误差为：

```
ε_max ≈ scale * (2Q + 1) ≈ 2 * √(scale * I)
```

当 `scale ≈ 1` 时：

```
ε_max ≈ 2√I
```

这仍在噪声范围内（约2σ）。

### 参数选择

#### offset（偏移量）

- **作用**: 移除固定背景
- **选择**: 设为图像的背景值
- **示例**: 如果背景为100计数，设 `offset=100`

#### scale（缩放因子）

- **作用**: 平衡精度和压缩率
- **选择指南**:
  - `scale=0.5`: 高精度（误差 ≤ √(2I)）
  - `scale=1.0`: 标准（误差 ≤ 2√I）
  - `scale=2.0`: 高压缩（误差 ≤ 2√(2I)）

#### 动态范围

原始uint16: 0-65535  
量化后uint8: 0-255

最大可表示的信号：

```
I_max = 255² * scale + offset
```

- `scale=1`: 最大65025
- `scale=2`: 最大130050（超出uint16，适合大信号）

## 霍夫曼编码

### 算法原理

霍夫曼编码是一种**最优前缀编码**，通过为高频符号分配短码字来实现压缩。

#### 构建过程

1. **统计频率**: 统计每个字节值的出现次数
2. **构建树**: 
   - 将所有符号作为叶节点，权重为频率
   - 重复合并权重最小的两个节点
   - 直到只剩一个根节点
3. **生成码表**: 
   - 从根到叶的路径编码（左=0，右=1）
   - 高频符号路径短，低频符号路径长

#### 示例

数据：`AAABBC`

频率：`A:3, B:2, C:1`

霍夫曼树：
```
      (6)
     /   \
   (3)   (3)
   A    /  \
       (2) (1)
       B    C
```

编码：`A:0, B:10, C:11`

压缩后：`000101011` (9位，原始48位)

### 实现优化

#### 查表编码

预先计算所有可能的编码，存储在表中：

```c
struct huffman_code {
    unsigned int code;  // 编码值
    unsigned int bits;  // 位数
};

huffman_code encode_table[256];
```

编码时直接查表，时间复杂度 O(1)。

#### 位操作

高效的位流写入：

```c
unsigned int bit_buffer = 0;
int bit_count = 0;

// 写入编码
bit_buffer |= (code << bit_count);
bit_count += bits;

// 刷新字节
while (bit_count >= 8) {
    *out++ = bit_buffer & 0xFF;
    bit_buffer >>= 8;
    bit_count -= 8;
}
```

#### 快速解码

使用**查找表**加速：

```c
// 预先构建解码表（假设最大码长16）
struct decode_entry {
    unsigned char symbol;
    unsigned char bits;
};

decode_entry decode_table[65536];  // 2^16

// 解码
int peek = *(unsigned short*)in;
decode_entry entry = decode_table[peek];
*out++ = entry.symbol;
in += entry.bits / 8;
```

## AVX优化

### SIMD并行化

AVX（Advanced Vector Extensions）允许同时处理多个数据。

#### 256位寄存器

AVX寄存器可容纳：
- 8个float（32位）
- 4个double（64位）

#### 量化的AVX实现

```c
void quantize_u16_avx(uint16_t *data, uint8_t *out, int size, 
                      float offset, float scale)
{
    __m256 voffset = _mm256_set1_ps(offset);
    __m256 vscale = _mm256_set1_ps(1.0f / scale);
    
    for (int i = 0; i < size; i += 8) {
        // 加载8个uint16，扩展为float
        __m128i vdata16 = _mm_loadu_si128((__m128i*)(data + i));
        __m256i vdata32 = _mm256_cvtepu16_epi32(vdata16);
        __m256 vdata_f = _mm256_cvtepi32_ps(vdata32);
        
        // 减去offset
        vdata_f = _mm256_sub_ps(vdata_f, voffset);
        
        // 除以scale
        vdata_f = _mm256_mul_ps(vdata_f, vscale);
        
        // 开方
        vdata_f = _mm256_sqrt_ps(vdata_f);
        
        // 转换为uint8
        __m256i vdata_i = _mm256_cvtps_epi32(vdata_f);
        __m128i vdata8 = _mm256_cvtepi32_epi8(vdata_i);
        
        // 存储
        _mm_storeu_si64(out + i, vdata8);
    }
}
```

#### 性能提升

理论上8倍加速，实际约3-4倍（受限于内存带宽）。

### CPU特性检测

运行时检测CPU是否支持AVX：

```c
#include <cpuid.h>

int has_avx() {
    unsigned int eax, ebx, ecx, edx;
    if (__get_cpuid(1, &eax, &ebx, &ecx, &edx)) {
        return (ecx & bit_AVX) != 0;
    }
    return 0;
}

void quantize_u16(uint16_t *data, uint8_t *out, int size,
                  float offset, float scale)
{
    if (has_avx()) {
        quantize_u16_avx(data, out, size, offset, scale);
    } else {
        quantize_u16_noavx(data, out, size, offset, scale);
    }
}
```

## 压缩流程

### 完整压缩流程

```
输入: uint16图像
  ↓
1. 量化 (uint16 → uint8)
  ↓
2. 霍夫曼编码 (uint8 → bitstream)
  ↓
输出: 压缩数据
```

### 解压流程

```
输入: 压缩数据
  ↓
1. 霍夫曼解码 (bitstream → uint8)
  ↓
2. 反量化 (uint8 → uint16)
  ↓
输出: 重建图像
```

## 性能分析

### 计算复杂度

| 操作 | 复杂度 | 说明 |
|-----|--------|------|
| 量化 | O(n) | 每像素一次运算 |
| 频率统计 | O(n) | 扫描一遍 |
| 霍夫曼树构建 | O(m log m) | m=256 |
| 编码 | O(n) | 每像素查表 |
| 解码 | O(n) | 查表解码 |

总体：**O(n)** 线性复杂度

### 内存使用

| 项目 | 大小 | 说明 |
|-----|------|------|
| 原始图像 | 2n | uint16 |
| 量化缓冲 | n | uint8 |
| 霍夫曼树 | ~4KB | 固定 |
| 编码表 | ~2KB | 256条目 |
| 压缩输出 | 0.3-0.5n | 视数据而定 |

峰值内存：约 **3n**

### 压缩率

#### 理论分析

随机泊松噪声的熵：

```
H ≈ log₂(σ) ≈ 0.5 * log₂(I)
```

对于 `I=100` 的信号：

```
H ≈ 0.5 * log₂(100) ≈ 3.3位/像素
```

量化后uint8的熵约 4-5位，霍夫曼编码后接近理论极限。

#### 实际压缩率

| 图像类型 | 原始大小 | 压缩后 | 压缩比 |
|---------|---------|--------|--------|
| 低信号(λ≈10) | 2字节 | 0.5字节 | 4x |
| 中信号(λ≈100) | 2字节 | 0.6字节 | 3.3x |
| 高信号(λ≈1000) | 2字节 | 0.7字节 | 2.9x |
| 均匀图像 | 2字节 | 0.4字节 | 5x |

### 吞吐量分析

在Intel Core i7 @ 3.5GHz上：

| 操作 | 标量版本 | AVX版本 | 加速比 |
|-----|---------|---------|--------|
| 量化 | 200 MB/s | 600 MB/s | 3x |
| 霍夫曼编码 | 500 MB/s | 500 MB/s | 1x |
| 霍夫曼解码 | 450 MB/s | 450 MB/s | 1x |

综合吞吐量：**500 MB/s** （瓶颈在霍夫曼编码）

## 与其他压缩算法对比

### 无损压缩

| 算法 | 压缩比 | 速度 | 特点 |
|-----|--------|------|------|
| PNG | 1.5-2x | 慢 | 通用图像 |
| LZ4 | 1.5-2x | 极快 | 通用数据 |
| Zlib | 2-3x | 中等 | 通用数据 |
| **Huffman** | 1.5-2x | 快 | 适合随机噪声 |

### 有损压缩

| 算法 | 压缩比 | 速度 | 误差 |
|-----|--------|------|------|
| JPEG | 10-20x | 快 | 不可控 |
| JPEG2000 | 10-30x | 慢 | 可控 |
| **HuffmanQuant** | 3-5x | 快 | **噪声内** |

### PYMECompress优势

1. **科学保真**: 误差在测量精度内
2. **高效**: 单核500+ MB/s
3. **简单**: 两步算法，易于实现
4. **硬件友好**: SIMD加速

### 局限性

1. **仅适用于泊松噪声图像**: 不适合自然照片
2. **压缩率中等**: 不如JPEG等有损算法
3. **需要先验知识**: 需要设置offset/scale参数

## 应用场景

### 适合

- 荧光显微镜成像
- 光子计数探测器
- 天文成像（CCD）
- 低光照成像
- 科学数据存档

### 不适合

- 自然照片
- 视频编码
- 高动态范围图像
- 需要极高压缩率的场景

## 未来改进方向

### 1. 自适应参数

自动估计offset和scale：

```python
def auto_params(image):
    offset = np.percentile(image, 1)  # 背景
    signal = np.mean(image - offset)
    scale = optimize_scale(signal)  # 基于信号强度
    return offset, scale
```

### 2. 分块编码

对不同区域使用不同参数：

```
图像 → 分块 → 各块独立编码 → 合并
```

### 3. 预测编码

利用时空相关性：

```
当前帧 ← 前一帧 + 残差
```

只编码残差，进一步提升压缩率。

### 4. GPU加速

使用CUDA并行化：
- 量化: 每线程处理一个像素
- 编码: 并行处理多个块

### 5. 更好的熵编码

替换霍夫曼为：
- 算术编码（更接近熵）
- ANS编码（更快的算术编码）

## 参考文献

1. Huffman, D.A. (1952). "A Method for the Construction of Minimum-Redundancy Codes"
2. Cover, T.M., & Thomas, J.A. (2006). "Elements of Information Theory"
3. Intel (2023). "Intel AVX Programming Reference"
4. Baddeley, D., et al. (2019). "PYMECompress: Compression for Photon-Noise Limited Images"

## 数学公式总结

### 量化

```
Q = ⌊√((I - offset) / scale)⌋
```

### 反量化

```
Î = Q² × scale + offset
```

### 误差上界

```
|I - Î| ≤ 2√(scale × I)
```

### 信噪比

```
SNR = signal / noise = I / √I = √I
```

### 压缩率估计

```
CR ≈ 16 / H(Q)
```

其中 H(Q) 是量化后的熵（位/像素）。

