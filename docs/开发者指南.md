# PYMECompress 开发者指南

## 开发环境搭建

### 克隆仓库

```bash
git clone https://github.com/python-microscopy/pymecompress.git
cd pymecompress
```

### 创建开发环境

#### 使用conda（推荐）

```bash
# Linux/macOS
conda create -n pymecompress-dev python=3.8 numpy cython pytest
conda activate pymecompress-dev

# Windows
conda create -n pymecompress-dev python=3.8 numpy cython libpython m2w64-toolchain pytest
conda activate pymecompress-dev
```

#### 使用pip

```bash
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
pip install pytest pytest-cov
```

### 安装开发版本

```bash
# 开发模式安装（推荐）
python setup.py develop

# 或使用pip
pip install -e .
```

## 项目构建系统

### 构建系统演进

PYMECompress支持两种构建系统：

1. **NumPy distutils**（传统方式）- `setup.py`
2. **Meson**（现代方式）- `meson.build` + `pyproject.toml`

#### NumPy distutils构建

```bash
# 清理
python setup.py clean

# 构建
python setup.py build_ext --inplace

# 安装
python setup.py install
```

#### Meson构建

```bash
# 安装meson-python
pip install meson-python

# 构建
python -m build

# 安装
pip install dist/*.whl
```

### Cython编译

Cython代码在构建时自动编译：

```bash
# 手动编译.pyx为.c
cython pymecompress/bcl.pyx

# 使用setup.py编译
python setup.py build_ext --inplace
```

**关键文件**:
- `pymecompress/bcl.pyx` - Cython源码
- `pymecompress/bcl.c` - 生成的C代码（提交到仓库）

### 编译选项

#### GCC/Clang优化选项

在`pymecompress/setup.py`中设置：

```python
extra_compile_args=[
    '-O3',              # 最高优化级别
    '-fno-exceptions',  # 禁用C++异常
    '-ffast-math',      # 快速数学运算
]
```

#### AVX支持

AVX代码通过numpy的dispatch机制编译：

```python
# quantize.dispatch.c 会自动生成两个版本：
# - quantize.dispatch.avx.c (AVX)
# - quantize.c (通用)
```

## 代码结构

### C代码组织

```
pymecompress/
├── bcl/
│   ├── huffman.c/h      # 霍夫曼编码核心
│   └── [其他BCL文件]    # 未使用的算法
├── quantize.c           # 量化算法实现
├── quantize.h           # 量化接口
├── quantize.dispatch.c  # CPU分发逻辑
└── bcl.pyx             # Cython包装
```

### Python代码组织

```
pymecompress/
├── __init__.py         # 公开API
├── codecs.py           # numcodecs接口
├── version.py          # 版本管理
└── cython_numpy_monkey.py  # 构建补丁
```

## 修改代码

### 修改C代码

1. **编辑量化算法** (`quantize.c`):

```c
void quantize_u16_avx(uint16_t *data, uint8_t *out, int size, 
                      float offset, float scale)
{
    // 你的修改
}
```

2. **重新编译**:

```bash
python setup.py build_ext --inplace
```

3. **测试**:

```bash
pytest test_pymecompress.py
```

### 修改Cython代码

1. **编辑** `pymecompress/bcl.pyx`:

```cython
def MyNewFunction(data):
    # 你的代码
    pass
```

2. **重新编译Cython**:

```bash
cython pymecompress/bcl.pyx
python setup.py build_ext --inplace
```

3. **更新公开API** (`pymecompress/__init__.py`):

```python
from .bcl import MyNewFunction
```

### 修改Python代码

1. **编辑** `pymecompress/codecs.py`:

```python
class MyNewCodec(Codec):
    codec_id = 'pymecompress-mynew'
    # ...
```

2. **无需重新编译**，直接测试即可

## 添加新功能

### 示例：添加新的压缩算法

#### 1. 在C中实现

编辑`pymecompress/bcl/myalgo.c`:

```c
unsigned int MyAlgo_Compress(unsigned char *in, unsigned char *out, 
                             unsigned int insize)
{
    // 实现你的算法
    return outsize;
}
```

#### 2. 在Cython中包装

编辑`pymecompress/bcl.pyx`:

```cython
cdef extern from "bcl/myalgo.h":
    unsigned int MyAlgo_Compress(unsigned char *in, unsigned char *out, 
                                 unsigned int insize)

def MyAlgoCompress(unsigned char[:] data):
    cdef unsigned int insize = data.shape[0]
    cdef unsigned int outsize = insize + 1024
    cdef np.ndarray[np.uint8_t, ndim=1] out = np.empty(outsize, 'uint8')
    
    cdef unsigned int size = MyAlgo_Compress(&data[0], &out[0], insize)
    return out[:size]
```

#### 3. 创建numcodecs编解码器

编辑`pymecompress/codecs.py`:

```python
class MyAlgo(Codec):
    codec_id = 'pymecompress-myalgo'
    
    def encode(self, buf):
        return bcl.MyAlgoCompress(buf)
    
    def decode(self, buf, out=None):
        return bcl.MyAlgoDecompress(buf, out)

numcodecs.register_codec(MyAlgo)
```

#### 4. 添加测试

编辑`test_pymecompress.py`:

```python
def test_myalgo_lossless():
    from pymecompress import codecs
    test_data = np.random.randint(0, 255, 1000, dtype='uint8')
    
    codec = codecs.MyAlgo()
    compressed = codec.encode(test_data)
    decompressed = codec.decode(compressed)
    
    assert np.allclose(decompressed, test_data)
```

#### 5. 更新setup.py

```python
config.add_extension(name='bcl',
                sources=['bcl.c', 'bcl/huffman.c', 'bcl/myalgo.c',
                        'quantize.dispatch.c', 'quantize.c'],
                # ...
```

## 测试

### 运行测试

```bash
# 运行所有测试
pytest

# 运行特定测试
pytest test_pymecompress.py::test_compression_lossless_uint16

# 带覆盖率
pytest --cov=pymecompress --cov-report=html

# 查看覆盖率报告
open htmlcov/index.html
```

### 添加测试

```python
def test_new_feature():
    """测试新功能"""
    import pymecompress
    import numpy as np
    
    # 准备测试数据
    data = np.random.randint(0, 255, 1000, dtype='uint8')
    
    # 测试功能
    result = pymecompress.new_function(data)
    
    # 断言
    assert result is not None
    assert len(result) > 0
```

### 性能测试

```python
import time
import numpy as np
from pymecompress import codecs

def benchmark_compression():
    data = np.random.poisson(100, 10000000).astype('uint16')
    codec = codecs.HuffmanQuant16(offset=0, scale=1.0)
    
    # 压缩
    start = time.time()
    compressed = codec.encode(data)
    compress_time = time.time() - start
    
    # 解压
    start = time.time()
    decompressed = codec.decode(compressed)
    decompress_time = time.time() - start
    
    # 统计
    compression_ratio = data.nbytes / len(compressed)
    throughput_compress = data.nbytes / compress_time / 1e6
    throughput_decompress = data.nbytes / decompress_time / 1e6
    
    print(f"压缩比: {compression_ratio:.2f}x")
    print(f"压缩吞吐量: {throughput_compress:.0f} MB/s")
    print(f"解压吞吐量: {throughput_decompress:.0f} MB/s")

if __name__ == '__main__':
    benchmark_compression()
```

## 调试

### Python调试

```python
# 使用pdb
import pdb; pdb.set_trace()

# 或使用ipdb
import ipdb; ipdb.set_trace()
```

### C/Cython调试

#### 使用gdb

```bash
# 编译调试版本
CFLAGS="-g -O0" python setup.py build_ext --inplace

# 使用gdb运行
gdb --args python test_script.py

# gdb命令
(gdb) break quantize_u16
(gdb) run
(gdb) print data[0]
```

#### 使用printf调试

在C代码中：

```c
#include <stdio.h>

void quantize_u16(uint16_t *data, uint8_t *out, int size, 
                  float offset, float scale)
{
    printf("DEBUG: size=%d, offset=%f, scale=%f\n", size, offset, scale);
    // ...
}
```

重新编译后运行。

## 代码风格

### Python代码

遵循PEP 8：

```bash
# 安装工具
pip install flake8 black

# 检查
flake8 pymecompress/

# 自动格式化
black pymecompress/
```

### C代码

- 使用4空格缩进
- 函数名使用下划线分隔
- 变量名使用驼峰或下划线
- 添加注释说明复杂逻辑

### Cython代码

- 遵循Python风格
- C声明使用`cdef`
- 类型标注清晰

## 文档

### 添加文档字符串

```python
def my_function(data, offset):
    """
    简短描述。
    
    详细描述...
    
    Parameters
    ----------
    data : np.ndarray
        输入数据
    offset : float
        偏移量
    
    Returns
    -------
    np.ndarray
        处理后的数据
    
    Examples
    --------
    >>> my_function(data, 0.5)
    array([...])
    """
    pass
```

### 构建文档

如果项目使用Sphinx：

```bash
cd docs
make html
```

## 发布流程

### 1. 更新版本号

编辑`pymecompress/version.py`:

```python
version='0.3.7'
```

编辑`pyproject.toml`:

```toml
version = "0.3.7"
```

### 2. 更新CHANGELOG

创建`CHANGELOG.md`记录变更：

```markdown
## [0.3.7] - 2024-01-15
### Added
- 新功能X

### Fixed
- 修复bug Y
```

### 3. 提交变更

```bash
git add .
git commit -m "Bump version to 0.3.7"
git tag v0.3.7
git push origin master --tags
```

### 4. 构建分发包

```bash
# 清理旧文件
rm -rf dist/ build/

# 构建源码包和wheel
python setup.py sdist bdist_wheel

# 检查
twine check dist/*
```

### 5. 上传到PyPI

```bash
# 测试PyPI
twine upload --repository-url https://test.pypi.org/legacy/ dist/*

# 正式PyPI
twine upload dist/*
```

### 6. 构建conda包

```bash
# 创建conda配方
conda skeleton pypi pymecompress

# 构建
conda build pymecompress

# 上传
anaconda upload /path/to/package.tar.bz2
```

## CI/CD

### Azure Pipelines

配置在`azure-pipelines.yml`：

```yaml
trigger:
- master

jobs:
- job: Test
  pool:
    vmImage: 'ubuntu-latest'
  steps:
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.8'
  - script: |
      pip install -r requirements.txt
      python setup.py develop
      pytest
```

### GitHub Actions

创建`.github/workflows/test.yml`:

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.6, 3.7, 3.8, 3.9]
    
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        python setup.py develop
    - name: Test
      run: pytest
```

## 常见开发问题

### Q1: Cython编译错误

**症状**: `fatal error: numpy/arrayobject.h: No such file or directory`

**解决**:
```bash
pip install numpy --upgrade
python setup.py build_ext --inplace
```

### Q2: AVX代码不生成

**症状**: `quantize.dispatch.avx.c`未生成

**解决**: 确保numpy版本 >= 1.14，并且使用`build_src`命令

### Q3: Windows链接错误

**症状**: `undefined reference to '__imp_PyExc_ValueError'`

**解决**: 确保安装了`libpython`和`m2w64-toolchain`

### Q4: 测试失败"数组不连续"

**症状**: `ValueError: ndarray is not C-contiguous`

**解决**: 在测试中使用`np.ascontiguousarray()`

## 贡献指南

### 提交PR流程

1. Fork项目
2. 创建特性分支：`git checkout -b feature/my-feature`
3. 提交变更：`git commit -am 'Add feature'`
4. 推送分支：`git push origin feature/my-feature`
5. 创建Pull Request

### PR检查清单

- [ ] 代码通过所有测试
- [ ] 添加了新功能的测试
- [ ] 更新了文档
- [ ] 遵循代码风格
- [ ] 提交信息清晰

### 代码审查

维护者会检查：
- 代码质量
- 测试覆盖
- 性能影响
- API兼容性

## 性能优化建议

### 1. 使用性能分析工具

```python
import cProfile
import pstats

cProfile.run('your_function()', 'stats.prof')
stats = pstats.Stats('stats.prof')
stats.sort_stats('cumulative').print_stats(10)
```

### 2. 优化关键路径

- 减少内存拷贝
- 使用原地操作
- 利用缓存局部性

### 3. SIMD优化

- 使用AVX/AVX2指令
- 对齐内存访问
- 向量化循环

### 4. 多线程

- 对于独立的帧，使用线程池
- 注意GIL限制
- 大部分时间应在C代码中

## 参考资源

- **Cython文档**: https://cython.readthedocs.io/
- **NumPy C API**: https://numpy.org/doc/stable/reference/c-api/
- **numcodecs**: https://numcodecs.readthedocs.io/
- **Meson构建**: https://mesonbuild.com/
- **Intel AVX指南**: https://software.intel.com/content/www/us/en/develop/articles/introduction-to-intel-advanced-vector-extensions.html

